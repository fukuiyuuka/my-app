■ログイン方法
主流なのは下の3つ

・セッション認証
	・ユーザーがログイン情報を送信
	・サーバーで認証し、セッションIDを発行
	・セッションIDをCookieに保存してブラウザへ送る（HttpOnly + Secure 推奨）
		※HttpOnly：Cookieを通信に付加することはできても、jsコードで中身を読み込めなくする。
		※Secure：HTTPS通信（暗号化通信）でのみCookieを送信可能。
	・クライアントは以後、リクエスト時にCookieを自動で送る
	・サーバーではセッションストア（メモリ・Redis・DBなど）でセッションIDとユーザ情報を紐づけておく必要がある

・トークン認証
	・ユーザーがログイン情報を送信
	・サーバーで認証し、トークン（認証情報をいい感じにコンパクトにまとめたもの）を発行
	・トークンをCookieに保存してブラウザへ送る（HttpOnly + Secure 推奨）
	・クライアントは以後、リクエスト時にCookieを自動で送る
	・トークンは認証情報そのもの。代表的なトークン形式にJWTがある。
		・JSON Web Token
			・３つの要素をドットで繋げた構成
				・ヘッダ：ペイロードの種類、暗号化アルゴリズムなどのメタ情報（のBASE64URLエンコード）
					※BASE64URLエンコード：文字列に変換（暗号化ではない）
				・ペイロード：認証情報の本体（のBASE64URLエンコード）
				・署名：ヘッダ+ペイロードをハッシュ化・暗号化したもの。改ざん検知
・外部認証（OAuth 2.0 / OpenID Connect）
	・他者サービスを利用（gmailアカウントなど。）

■メリット・デメリット

・セッション認証
	・メリット：セッションIDがばれても認証情報そのものはばれない
		・盗んでも、セッションが期限切れになってしまえばもう悪用できない
	・デメリット：サーバでセッションIDとユーザ情報の紐づけを保持しなければいけない。（ステートフル）
		・ユーザが多い場合などは、この情報で圧迫されてしまう。
		・複数サーバがあったりすると、セッション情報の共有が面倒

・トークン認証
	・メリット：一度トークンを発行すれば、サーバで管理したりする必要がない。
	・デメリット
		・認証情報そのものなので、ばれたらずっと悪用できてしまう。
			・XSS攻撃に弱い
				・XSSは「悪意のあるコードを脆弱性を利用して正規のアプリ内で動かす攻撃」
				・ユーザ入力値をそのままhtmlに埋め込んでいたりすると、悪意あるスクリプトを読み込む処理を埋め込めてしまう。
					→サニタイズ（スクリプト埋め込みの防止）が重要
				・XSSによってトークンが抜き取られた際の被害は、セッションよりも大きくなる。
				・localStorageやsessionStorageは、jsで簡単に読み取れるのでcookieよりも漏洩リスクが高い
					

※クライアント側で値を保持する方法（いずれもブラウザの標準機能）
	・cookie：HTTP通信時に自動で送信される。
		・そのままではCSRFの危険性
			・Cookieは、デフォルトではブラウザ上のどのアプリから作成されたかに関わらず、全ての通信に対して付加される。
			・これを利用し、Cookie上の他サイトの認証情報を使って不正にアクセスするのがCSRF攻撃
			・目的のサイトのクライアントアプリのオリジンを使用するので、CORSポリシーにも引っかからずに通ってしまう。
			・対策
				・SameSite属性：Cookieを、そのCookieを作ったアプリ上の通信でしか利用できないようにする。
				・CSRFトークン
					・送ったHTMPにCSRFトークンという文字列を埋め込み、2段階認証させる。
					・HTMLとスクリプト、HTTP通信にしか現れず、ブラウザに保存されないので盗むのが難しい。
		・HttpOnly + Secureにすれば、スクリプトから読み込まれなくなるので、認証情報を置くのに適している。
	・localStorage：アプリが終了しても（タブを閉じても）残る。スクリプトから簡単に読み込めてしまう。
	・sessionStorage：タブを閉じたら消える。スクリプトから簡単に読み込めてしまう。


・外部認証
	・メリット：ユーザにとってログインが楽。セキュリティ管理しやすい。
	・デメリット：外部サービスに依存。実装が複雑。

■何を採用する？

・セッション認証を採用
	・スケーラビリティは今回考慮しない
	・安全性はこちらが高い。
	・学習コストも低そう。

・セッション認証
	・HttpOnly + Secure なCookieにセッションIDを保存すれば、XSS対策もできてセキュア。
	・サーバが状態を管理できるため、トークンの無効化やログアウト処理が明快。
	・フロントは「ただCookieがあるかどうか」でログイン状態を判断でき、実装がシンプル。

■実装方法の検討
セッションログインを採用

・サーバ側
	・セッションの生成
		・express-sessionミドルウェアを使用
		・もしその通信がセッションを保持していない場合は、セッションを生成しリクエストに付加してくれる
		・req.sessionへのアクセスが発生し、undefinedだった場合に自動で生成。
			app.use(session({
				secret: "secret",
				resave: false,
				saveUninitialized: false,
				store: new RedisStore({ client: redisClient }), // Redisを使う場合
				cookie: {
					httpOnly: true,　//スクリプトからの値の読み取り不可
					secure: true, //HTTPS通信でのみ送信可能
					sameSite: "Strict"　//他サイトのリクエストに付加しない。
				}
			}));
		・Cookieに以下の設定を行う。

	・セッションを使った認証
		・セッションにはログイン状態が保持させる。
			・生成直後のセッションは、未ログイン状態（req.session.logined = false）
				・未ログイン状態
					・ログイン画面からのリクエスト（パスが/loginかどうかで判断）
						・ログイン処理（ID・パスワード照合）を行う
							・ログイン処理成功
								・セッションストアにセッションIDとユーザ情報を紐づけ。
									・req.session.logined = true
									・req.session.userId =userId
								・成功レスポンス。
									・Set-Cookieに自動でセッションIDが置かれる。
									・Set-Cookieにセットされた値は、ブラウザで自動的にCookieに保存される。
							・ログイン失敗：失敗レスポンスする
			・セッションがログイン済みなら、セッションストアからユーザ情報を取得
					・取得できなければ、失敗レスポンス。フロントでログイン画面に戻す。
					・取得できたら、続きの処理を行う。
	・セッションの保存（ユーザとの紐づけ）
		・セッションストアはconnect-redisを使用。
			const RedisStore = connectRedis(expressSession);
			const store = new RedisStore({ client: redis });
		・express-sessionにstoreインスタンスを設定すれば、生成時に自動でセッションをストアに保存してくれる。
・クライアント側
	・セッションの保存
		・サーバからのレスポンスで自動的に保存。
	・セッションの送信
		・Cookieに保存しておけば、自動的に送信される。
		・クロスオリジンの場合は、withCredentialsが必要
			axios.get("https://api.example.com/data", {
				withCredentials: true
			});
	・検討：CSRF対策用トークン


